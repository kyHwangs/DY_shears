#include "Pruner.h"

#include <iostream>
#include <vector>
#include "TLorentzVector.h"
#include <cstdlib>

#if __GNUC__ < 5
  #error "You're using an old compiler version. Run cmsenv."
#endif

using namespace std;

//Includes code generated by TTree:MakeClass():
//The fields of EventTree.h class will be used
//to access the EventTree contents. EventTree::Init(TTree*)
//should be called by the init(Tree*) method to link these
//fields to the EventTree contents.
#define EventTree_cxx
#include "EventTree.h"
void EventTree::Loop(){} //To make the linker happy.

/** Selection parameters **/

static float minGJetPt = 10;

static float minLepPt = 15;

const constexpr static float maxElIsoFourLep = 0.3;
const constexpr static float maxMuIsoFourLep = 0.4;
const constexpr static float minPtFourLep = 4;

static float minJetAk04Pt = 15;

static float mll_low = 66;
static float mll_high = 126;

static const unsigned elIdMask = 0b11111;

//For data v11
//static const unsigned elIdMask = (1 <<20);

/**************************/


class VJetPruner: public Pruner, EventTree{
protected:
  void declareSubSelections();
  bool init(TChain* tree);
  bool filterEvent();
  
  bool filterGLep(int iGenLep);
  bool filterGJet(int iGenLep);

  bool filterEl(int iEl);
  bool filterMu(int iMu);
  bool filterJetAk04(int iJetAk04);

  bool filterElFourLep(int iEl);
  bool filterMuFourLep(int iMu);
  
  void makeFilterMask(bool (VJetPruner::*filter)(int), std::vector<bool>& mask);
  void skimCollections();
  bool eventSelection();
  double mll(std::vector<float>* lepColPt, std::vector<float>* lepColEta,
	     std::vector<float>* lepColPhi, std::vector<float>* lepColE,
	     std::vector<int>* lepColId = 0, int pid = 0);
  enum { DMu, DMuUnf, DMuMass, DE, DEUnf, DEMass, EMu, SE, SEUnf, SMu, SMuUnf, FourLep, FourLepUnf, NSubSels};

  static const int kEl = 11;
  static const int kMu = 13;
};

DECLARE_PRUNER(VJetPruner, "Pruner of W/Z/H + jet analyses")

void VJetPruner::declareSubSelections(){
  subSelections_.resize(NSubSels);
  subSelections_[DMu]    = SubSelection("DMu", "Dimuon selection for Z+jet analysis");
  subSelections_[DMuUnf] = SubSelection("DMuUnf", "Dimuon selection for Z+jet analysis with MC selection suitable to fill the detector response matrices for the unfolding.");
  subSelections_[DMuMass] = SubSelection("DMuMass", "Dielectron selection for Z+jet analysis including dilepton mass window");
  subSelections_[DE]     = SubSelection("DE","Dielectron selection for Z+jet analysis");
  subSelections_[DEUnf]  = SubSelection("DEUnf", "Dielectron selection for Z+jet analysis with MC selection suitable to fill the detector response matrices for the unfolding.");
  subSelections_[DEMass] = SubSelection("DEMass", "Dimuon selection for Z+jet analysis including dilepton mass window");
  subSelections_[EMu]    = SubSelection("EMu", "Electron-muon selection for background control region");
  subSelections_[SE]     = SubSelection("SE", "Single electron selection for W+jet analysis");
  subSelections_[SEUnf]  = SubSelection("SEUnf", "Single electron selection for W+jet analysis with MC selection suitable to fill the detector response matrices for the unfolding.");
  subSelections_[SMu]    = SubSelection("SMu", "Single muon selection for W+jet analysis");
  subSelections_[SMuUnf] = SubSelection("SMuUnf", "Single muon selection for W+jet analysis with MC selection suitable to fill the detector response matrices for the unfolding.");
  subSelections_[FourLep]    = SubSelection("FourLep", "Four-lepton selection for H+jet analysis");
  subSelections_[FourLepUnf] = SubSelection("FourLepUnf", "Four-lepton selection for H+jet analysis with MC selection suitable to fill the detector response matrices for the unfolding.");
}

bool VJetPruner::init(TChain* tree){
  if(tree == 0) return false;
  EventTree::Init(tree);
  return true;
}

void VJetPruner::makeFilterMask(bool (VJetPruner::*filter)(int), std::vector<bool>& mask){
  for(unsigned i = 0; i < mask.size(); ++i){
    mask[i] = (this->*filter)(i);
  }
}

bool VJetPruner::filterEvent(){
  skimCollections();
  return eventSelection() && Pruner::filterEvent();
}
  
void VJetPruner::skimCollections(){
  std::vector<bool> mask;

  bool isFourLep = (iSubSelection_ == FourLep || iSubSelection_ == FourLepUnf);
  
  //Gen lepton collections:
  if (!isFourLep) {
    mask.resize(GLepDr01Pt->size());
    makeFilterMask(&VJetPruner::filterGLep, mask);
    filter(GLepDr01Pt,  mask);
    filter(GLepDr01Eta, mask);
    filter(GLepDr01Phi, mask);
    filter(GLepDr01E,   mask);
    filter(GLepDr01Id,  mask);
    filter(GLepDr01St,  mask);
    filter(GLepDr01MomId, mask);
    filter(GLepDr01Prompt, mask);
    filter(GLepDr01TauProd, mask);
  }

  //Gen jet collections:
  mask.resize(GJetAk04Pt->size());
  makeFilterMask(&VJetPruner::filterGJet, mask);
  filter(GJetAk04Pt,  mask);
  filter(GJetAk04Eta, mask);
  filter(GJetAk04Phi, mask);
  filter(GJetAk04E,   mask);
  filter(GJetAk04ChFrac, mask);

  //Reco muon collections:
  mask.resize(MuPt->size());
  //printf("makeFilterMask(&VJetPruner::filterMu, mask);\n");
  makeFilterMask(isFourLep ? &VJetPruner::filterMuFourLep : &VJetPruner::filterMu, mask);
  filter(MuPt, mask);
  filter(MuEta, mask);
  filter(MuPhi, mask);
  filter(MuE, mask);
  for(size_t i=0;i<MuId->size();i++){
    //    printf("MuId(%ld)=%d\n",i,MuId->at(i));
    printf("MuId(%ld)=0x%x\n",i,MuId->at(i));
  }
  filter(MuId, mask);
  filter(MuIdTight, mask);
  for(size_t i=0;i<MuIdTight->size();i++){
    //    printf("MuId(%ld)=%d\n",i,MuId->at(i));
    printf("MuIdTight(%ld)=0x%x\n",i,MuIdTight->at(i));
  }
  filter(MuIdHighPt, mask);
  filter(MuIdTkHighPt, mask);

  filter(MuCh, mask);
  filter(MuVtxZ, mask);
  filter(MuDxy, mask);
  filter(MuIsoRho, mask);
  filter(MuPfIso, mask);
  filter(MuType, mask);
  filter(MuIsoTkIsoAbs, mask);
  filter(MuIsoTkIsoRel, mask);
  filter(MuIsoCalAbs, mask);
  filter(MuIsoCombRel, mask);
  filter(MuTkNormChi2, mask);
  filter(MuTkHitCnt, mask);
  filter(MuMatchedStationCnt, mask);
  filter(MuDz, mask);
  filter(MuPixelHitCnt, mask);
  filter(MuTkLayerCnt, mask);
  filter(MuPfIsoChHad, mask);
  filter(MuPfIsoNeutralHad, mask);
  filter(MuPfIsoRawRel, mask);
  filter(MuHltMatch, mask);

  //Reco electron collections:
  mask.resize(ElPt->size());
  makeFilterMask(isFourLep ? &VJetPruner::filterElFourLep : &VJetPruner::filterEl, mask);
  filter(ElPt, mask);
  filter(ElEta, mask);
  filter(ElEtaSc, mask);
  filter(ElPhi, mask);
  filter(ElE, mask);
  filter(ElId, mask);
  filter(ElCh, mask);
  filter(ElScRawE, mask);
  filter(ElCorrE, mask);
  filter(ElEcalIso, mask);
  filter(ElEcalPfIso, mask);
  filter(ElMvaTrig, mask);
  filter(ElMvaNonTrig, mask);
  filter(ElMvaPresel, mask);
  filter(ElDEtaTkScAtVtx, mask);
  filter(ElDPhiTkScAtVtx, mask);
  filter(ElHoE, mask);
  filter(ElSigmaIetaIeta, mask);
  filter(ElSigmaIetaIetaFull5x5, mask);
  filter(ElEinvMinusPinv, mask);
  filter(ElD0, mask);
  filter(ElDz, mask);
  filter(ElExpectedMissingInnerHitCnt, mask);
  filter(ElPassConvVeto, mask);
  filter(ElHltMatch, mask);
  filter(ElPfIsoChHad, mask);
  filter(ElPfIsoNeutralHad, mask);
  filter(ElPfIsoIso, mask);
  filter(ElPfIsoPuChHad, mask);
  filter(ElPfIsoRaw, mask);
  filter(ElPfIsoDbeta, mask);
  filter(ElPfIsoRho, mask);
  filter(ElAEff, mask);
  filter(ElDr03TkSumPt, mask);
  filter(ElDr03EcalRecHitSumEt, mask);
  filter(ElDr03HcalTowerSumEt, mask);
  
  //Reco jet collections:
  mask.resize(JetAk04Pt->size());
  makeFilterMask(&VJetPruner::filterJetAk04, mask);
}


//to be run after skimCollections
bool VJetPruner::eventSelection(){
  //count gen leptons:
  int GElCnt = 0;
  int GMuCnt = 0;
  for(unsigned i = 0; i < GLepDr01Id->size(); ++i){
    if(fabs((*GLepDr01Id)[i]) == kEl) ++GElCnt;
    if(fabs((*GLepDr01Id)[i]) == kMu) ++GMuCnt;
  }  

  float m;
  switch(iSubSelection_){
  case DMu:
    return MuPt->size() > 1;
  case DMuUnf:
    return MuPt->size() > 1  || GMuCnt > 1;
  case DMuMass:
    m = mll(MuPt,MuEta,MuPhi,MuE);
    return MuPt->size() > 1 && mll_low < m && m < mll_high;
  case DE:
    return ElPt->size() > 1;
  case DEUnf:
    return ElPt->size() > 1 || GElCnt > 1;
  case DEMass:
    m = mll(ElPt,ElEta,ElPhi,ElE);
    return ElPt->size() > 1 && mll_low < m && m < mll_high;
  case EMu:
    return ElPt->size() > 0 && MuPt->size() > 0;
  case SE:
    return ElPt->size() > 0;
  case SEUnf:
    return ElPt->size() > 0 || GElCnt > 0;
  case SMu:
    return MuPt->size() > 0;
  case SMuUnf:
    return MuPt->size() > 0 || GMuCnt > 0;
  case FourLep:
    return MuPt->size() + ElPt->size() >= 4;
  case FourLepUnf:
    return MuPt->size() + ElPt->size() >= 4 || GMuCnt + GElCnt >= 4;
  case NSubSels:
  default:
    return false;
  }
};

double VJetPruner::mll(std::vector<float>* lepColPt, std::vector<float>* lepColEta,
		       std::vector<float>* lepColPhi, std::vector<float>* lepColE, 
		       std::vector<int>* lepColId, int pid){
  int i0 = -1; double pt0 = 0;
  int i1 = -1; double pt1 = 0;
  //look for the two highest pt leptons:
  for(size_t i = 0; i < lepColPt->size(); ++i){
    if(lepColId && abs((*lepColId)[i]) != pid) continue;
    if((*lepColPt)[i] > pt0) {
      i1 = i0;
      pt1 = pt0;
      i0 = i;
      pt0 = (*lepColPt)[i];
    } else if((*lepColPt)[i] > pt1) {i1 = i; pt1 = (*lepColPt)[i]; }
  }
  std::cerr << __FILE__ << ":" << __LINE__ << ": " << i0 << i1 << "\n";
  if(i1 <0) return -1;
  else{
    TLorentzVector v0;
    v0.SetPtEtaPhiE((*lepColPt)[i0],(*lepColEta)[i0],(*lepColPhi)[i0],(*lepColE)[i0]);
    TLorentzVector v1;
    v1.SetPtEtaPhiE((*lepColPt)[i1],(*lepColEta)[i1],(*lepColPhi)[i1],(*lepColE)[i1]);
    return (v0 + v1).M();
  }
}

bool VJetPruner::filterGLep(int iGenLep){
  return ((*GLepDr01Pt)[iGenLep] > minLepPt);
}

bool VJetPruner::filterGJet(int iGenJ){
  return (*GJetAk04Pt)[iGenJ] > minGJetPt;
}

bool VJetPruner::filterMu(int iMu){
  return ((*MuPt)[iMu] > minLepPt);
}

bool VJetPruner::filterEl(int iEl){
  return ((*ElPt)[iEl] > minLepPt) && ((*ElId)[iEl] & elIdMask);
}

bool VJetPruner::filterMuFourLep(int iMu) {
  bool passesAnyId = ((*MuId)[iMu] != 0);
  for (auto id : *MuIdTight) passesAnyId |= (id != 0);
  for (auto id : *MuIdSoft) passesAnyId |= (id != 0);
  for (auto id : *MuIdHighPt) passesAnyId |= (id != 0);
  for (auto id : *MuIdTkHighPt) passesAnyId |= (id != 0);
  return ((*MuPt)[iMu] > minPtFourLep && (*MuPfIso)[iMu] < maxMuIsoFourLep && passesAnyId);
}

bool VJetPruner::filterElFourLep(int iEl) {
  return ((*ElPt)[iEl] > minPtFourLep && (*ElPfIsoRho)[iEl] < maxElIsoFourLep && (*ElId)[iEl] != 0);
}

bool VJetPruner::filterJetAk04(int iJetAk04){
  return (*JetAk04Pt)[iJetAk04] > minJetAk04Pt;
}

